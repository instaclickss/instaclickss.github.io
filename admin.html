<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css">
    <title>InstaClicks</title>
    <style>
        body {
            display: flex;
            margin: 0px;
            height: 100vh;
            background-color: #ffffff;
            gap: 1px;
            overflow: hidden;
        }

        .playerCont {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            padding: 10px;
            background-color: #ffffff;
            width: 40vw;
            max-width: 500px;
            min-width: 350px;
            height: 80vh;
            overflow-x: hidden;
            overflow-y: auto;
        }

        @media (max-width: 700px) {

            body {
                flex-direction: column;
            }

            .terminal,
            .entryLog {
                height: 50vh;
            }

            .playerCont {
                width: 80vw;
            }

        }

        .terminal,
        .entryLog {
            flex: 1;
            background-color: #000000;
        }

        .player {
            aspect-ratio: 1 / 1;
            width: 100%;
            align-self: center;
        }

        .closePlayerCont {
            width: 6%;
            align-self: end;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .pauseResume {
            width: 6%;
            align-self: center;
            margin-top: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .recordings {
            display: flex;
            flex-direction: column;
            align-self: center;
            align-items: center;
        }

        .recordings b {
            margin: 0px;
            margin-bottom: 5px;
            cursor: pointer;
        }

        .recordings b:hover,
        .selected {
            text-decoration: underline;
        }
    </style>
    <script>
        function rnd(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        class CCTVPlayer {

            constructor(player) {
                this.player = player;
                this.player.style.backgroundColor = "#000000";
                this.player.style.display = "flex";
                this.player.style.alignItems = "center";
                this.player.style.justifyContent = "center";

                this.paused = false;
                this.loopSessionId = 0;
                this.tape;
                this.sessionId;
                this.latestResolution;
                this.eventIndex;
                this.container;
                this.iframe;
                this.cursor;
                this.doc;
                this.win;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            raf() {
                return new Promise(resolve => {
                    this._rafId = requestAnimationFrame(resolve);
                });
            }

            cancelRaf() {
                if (this._rafId) cancelAnimationFrame(this._rafId);
            }

            play(tape) {

                this.loopSessionId++;
                var loopSessionId = this.loopSessionId;

                this.tape = tape;
                this.eventIndex = 1;
                this.latestResolution = { width: this.tape[0][2], height: this.tape[0][3] };

                var resizeIframe = () => {
                    var playerRect = this.player.getBoundingClientRect();
                    var screenW = this.latestResolution.width;
                    var screenH = this.latestResolution.height;

                    var scaleW = playerRect.width / screenW;
                    var scaleH = playerRect.height / screenH;
                    var scale = Math.min(scaleW, scaleH);

                    this.container.style.width = screenW * scale + "px";
                    this.container.style.height = screenH * scale + "px";

                    this.iframe.style.width = screenW + "px";
                    this.iframe.style.height = screenH + "px";
                    this.iframe.style.transform = `scale(${scale})`;
                }

                var playTape = async () => {

                    if (loopSessionId !== this.loopSessionId) return;
                    if (this.eventIndex >= this.tape.length - 1) return;

                    if (!this.paused) {

                        let event = this.tape[this.eventIndex];
                        
                        try {
                            switch (event[0]) {
                                case 0:
                                    await this.sleep(event[1]);
                                    break;
                                case 1:
                                    this.cursor.style.left = event[1] + "px";
                                    this.cursor.style.top = event[2] + "px";
                                    break;
                                case 2:
                                    let elements = this.doc.elementsFromPoint(event[1], event[2]);
                                    elements.forEach(el => {
                                        el.focus();
                                        ["mousedown", "mouseup", "click"].forEach(type => {
                                            let evt = new MouseEvent(type, {
                                                view: window,
                                                bubbles: true,
                                                cancelable: true,
                                                clientX: event[1],
                                                clientY: event[2],
                                                buttons: 1
                                            });
                                            el.dispatchEvent(evt);
                                        });
                                    });
                                    this.cursor.style.left = event[1] + "px";
                                    this.cursor.style.top = event[2] + "px";
                                    break;
                                case 3:
                                    this.win.scrollTo(event[1], event[2]);
                                    break;
                                case 4:
                                    this.latestResolution = { width: event[1], height: event[2] };
                                    resizeIframe();
                                    break;
                            }
                        } catch {
                            console.log(this.iframe);
                            console.log(this.win);
                        }

                        this.eventIndex += 1;

                    }

                    await this.raf();
                    playTape();

                }

                if (this.sessionId != this.tape[0][0]) {
                    this.sessionId = this.tape[0][0];

                    this.player.innerHTML = "";

                    this.container = document.createElement("div");
                    this.container.style.overflow = "hidden";
                    this.player.appendChild(this.container);

                    this.iframe = document.createElement("iframe");
                    this.iframe.src = this.tape[0][1];
                    this.iframe.style.border = "none";
                    this.iframe.style.pointerEvents = "none";
                    this.iframe.style.transformOrigin = "top left";
                    this.iframe.style.backgroundColor = "#ffffff";
                    this.container.appendChild(this.iframe);

                    resizeIframe();

                    var observer = new ResizeObserver(resizeIframe);
                    observer.observe(this.player);

                    this.iframe.addEventListener("load", () => {

                        this.iframeLoaded = true;
                        this.doc = this.iframe.contentDocument || this.iframe.contentWindow.document;
                        this.win = this.iframe.contentWindow;

                        this.cursor = this.doc.createElement("div");
                        this.cursor.style.position = "fixed";
                        this.cursor.style.backgroundColor = "#ff0000";
                        this.cursor.style.width = "10px";
                        this.cursor.style.height = "10px";
                        this.cursor.style.top = "0px";
                        this.cursor.style.left = "0px";
                        this.cursor.style.pointerEvents = "none";
                        this.cursor.style.zIndex = "999";
                        this.doc.body.appendChild(this.cursor);

                        playTape();

                    });
                } else {
                    playTape();
                }

            }

            pause() {
                this.paused = true;
            }

            resume() {
                this.paused = false;
            }

        }
    </script>
</head>
<body>
    <div class="terminal"></div>
    <div class="entryLog"></div>
    <div style="display: none" class="playerCont">
        <img class="closePlayerCont" src="https://cdn-icons-png.flaticon.com/512/1828/1828778.png">
        <div class="player"></div>
        <img class="pauseResume" src="https://cdn-icons-png.flaticon.com/512/151/151859.png">
        <div class="recordings"></div>
    </div>
    <script>
        var term = new Terminal();
        var entryLog = new Terminal();
        var termFit = new FitAddon.FitAddon();
        var entryLogFit = new FitAddon.FitAddon();
        var server = "https://jointly-secure-weevil.ngrok-free.app";
        var entries = [];
        var playerCont = document.querySelector(".playerCont");
        var closePlayerCont = document.querySelector(".closePlayerCont");
        var pauseResume = document.querySelector(".pauseResume");
        var recordings = document.querySelector(".recordings");
        var player = document.querySelector(".player");
        var cctvPlayer = new CCTVPlayer(player);

        closePlayerCont.addEventListener("dragstart", e => e.preventDefault());
        pauseResume.addEventListener("dragstart", e => e.preventDefault());

        closePlayerCont.addEventListener("click", function () {
            playerCont.style.display = "none";
        });

        pauseResume.addEventListener("click", function () {
            if (cctvPlayer.paused) {
                cctvPlayer.paused = false;
                pauseResume.src = "https://cdn-icons-png.flaticon.com/512/151/151859.png";
            } else {
                cctvPlayer.paused = true;
                pauseResume.src = "https://cdn-icons-png.flaticon.com/512/5577/5577228.png";
            }
        });

        term.loadAddon(termFit);
        entryLog.loadAddon(entryLogFit);
        term.open(document.querySelector(".terminal"));
        entryLog.open(document.querySelector(".entryLog"));

        function resizeTerminals() {
            termFit.fit();
            entryLogFit.fit();
        }

        setInterval(resizeTerminals, 0);

        var buffer = "";
        term.write("> ");

        term.onData(async e => {
            if (e.charCodeAt(0) === 13) {
                term.write("\r\n");

                if (buffer === "") {
                    term.write("> ");
                } else if (buffer === "cls") {
                    term.clear();
                    buffer = "";
                    term.write("> ");
                } else {
                    await handleCommand(buffer);
                    buffer = "";
                    term.write("\r\n> ");
                }

            } else if (e.charCodeAt(0) === 127) {
                if (buffer.length > 0) {
                    buffer = buffer.slice(0, -1);
                    term.write("\b \b");
                }
            } else {
                buffer += e;
                term.write(e);
            }
        });

        async function handleCommand(cmd) {
            if (cmd === "help") {
                term.write("users     | gets all website's viewers\r\n");
                term.write("views     | gets website's view count\r\n");
                term.write("cctv [id] | opens a player with recordings from a user by id\r\n")
            } else if (cmd === "users") {
                var res = await fetch(server + "/getUsers", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ password: password })
                });
                var data = await res.json();
                for (let user of data.users) {
                    user.navigatorObj = JSON.parse(user.navigatorObj);
                    user.navigatorObj.languages = JSON.parse(user.navigatorObj.languages);
                }
                var formatted = JSON.stringify(data.users, null, 4);
                formatted.split("\n").forEach(line => term.writeln(line));
            } else if (cmd === "views") {
                var res = await fetch(server + "/getUsers", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ password: password })
                });
                var data = await res.json();
                term.write(`${data.users.length}\r\n`);
            } else if (cmd.split(" ")[0] === "cctv") {
                var id = cmd.split(" ")[1];
                var res = await fetch(server + "/getRecordings", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ password: password, id: id })
                });
                var data = await res.json();
                if (data.status != 200) {
                    term.write("Couldn't get recordings\r\n");
                    return;
                }
                var seshCat = {};
                for (let recording of data.recordings) {
                    let sesh = recording[0][0];
                    if (!seshCat.hasOwnProperty(sesh)) {
                        seshCat[sesh] = [];
                    }
                    seshCat[sesh].push(recording);
                }

                recordings.innerHTML = "";

                for (let sesh in seshCat) {
                    var duration = 0;
                    var startData = seshCat[sesh][0][0];
                    for (let recording of seshCat[sesh]) {
                        recording.shift()
                    }
                    var recording = seshCat[sesh].flat();
                    recording.unshift(startData);

                    for (let event of recording) {
                        if (event[0] == 0) {
                            duration += event[1];
                        }
                    }

                    let seshTitle = document.createElement("b");
                    seshTitle.innerText = `${sesh} ${startData[4]} (${duration} ms)`;
                    seshTitle.addEventListener("click", function () {
                        var selected = document.querySelector(".selected");
                        if (selected) {
                            selected.classList.remove("selected");
                        }
                        seshTitle.classList.add("selected");
                        cctvPlayer.play(recording);
                    })
                    recordings.appendChild(seshTitle);
                }
                playerCont.style.display = "";
            } else {
                term.write("Unknown command: " + cmd + "\r\n");
                term.write('Type "help" for a command list\r\n');
            }
        }

        setInterval(async () => {
            var res = await fetch(server + "/getEntries", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ password: password })
            });
            var data = await res.json();
            var oldEntries = new Set(entries);
            var changes = data.entries.filter(item => !oldEntries.has(item));
            for (let entry of changes) {
                entryLog.write(entry + "\r\n");
            }
            entries = data.entries;
        }, 5000);
    </script>
</body>
</html>